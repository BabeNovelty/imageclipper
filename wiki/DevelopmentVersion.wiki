=Abstract=

It is often required to clip images manually fast for computer vision researchers to gather training and testing image sets, e.g., clipping faces in images.

This simple multi-platform (Windows and Linux were verified) software helps you to clip images manually fast. 

=Download=

http://code.google.com/p/imageclipper/downloads/list

A binary for Windows is available. 
Drag and Drop a folder (including pictures) or a picture or a video file on exe. 
You can also execute it on the command prompt. 
No installer is included for this simple software. 

PS. It may be required to install [http://www.microsoft.com/downloads/details.aspx?FamilyID=200b2fd9-ae1a-4a14-984d-389c36f85647&DisplayLang=en Microsoft Visual C++ 2005 SP1 Redistributable Package] (if you have never installed this or Visual Studio 2005 itself). I am looking for how not to require users to install it. Not to use VC++ 2005? 

=What You Can Do=

  * You can open images in a directory sequentially
  * You can open a video file too, frame by frame
  * Clipping and moving to the next image can be done by one button (SPACE)
  * You will initialize a region to clip by dragging left mouse button
  * You can move or resize your selected region by hotkeys or dragging right mouse button. 
  * Your selected region is shown on the next image too. 
  * You can select the output image filename format (command line)

=How to Use (Application Usage)=

(Windows) Drag and drop a folder or an image file or a video file on imageclipper.exe. 

(Windows and Linux) Execute as a command line tool. See *How to Use (Command Usage)* section. 

Select a region where you want to clip by dragging left mouse button. 
You can move or resize your selected region by dragging right mouse button. 
Drag inside the rectangle to move, and drag outside the rectangle to resize. 

http://imageclipper.googlecode.com/files/snapshot.png

  * Use <s> key to save the region as an image. Saved filename is shown on the command prompt. 
  * Use <f> key to move forward to the next image in the same directory
  * Use <SPACE> key to save and move to the next
  * Use <b> key to move backward to the previous image (not available for video now)
  * Use <q> or <ESC> key to quit application (Sorry, but OpenCV GUI does not support to quit an application by closing window. Use Ctrl-c if command prompt is left alone.)
  * Use <r> to rotate the rectangle region in couter-clockwise. <R> (Shift-<r>) to roate in clockwise.
  * Use <e> to expand the size of window. <E> (Shift-<e>) to shrink the size of window.
  * Note that above keys are located on the left hand keyboard region. 
  * Use <h> left <j> down <k> up <l> right to move the rectangle region ([http://en.wikipedia.org/wiki/Vi vi]-like keybind)
  * Use <y> left <u> down <i> up <o> right to move the rectangle's right-bottom boundary, that is, to resize in x and y directions. 
  * Note that these keys to be used instead of mouse are located on the right hand keyboard region. 

When you move to the next image, you will see a rectangle that you made before at the same place with the same size. You may simply move the rectangle by right button dragging to choose a new region. 

The clipped images are saved as
{{{
<dirname>/imageclipper/<basename>_<left_upper_x>_<left_upper_y>_<width>_<height>.png
}}}
such as
{{{
../myimages/imageclipper/lena.jpg_0109_0093_0065_0090.png
}}}
when the original filename is ../myimages/lena.jpg. 
This software creates a directory "imageclipper" under the directory (folder) where the input image is located and store images under the directory as a default.  

The target directory and the filename format can be modified via a command line option. 
You can choose a different image type by specifying a different file extension. See "How to Use (Command Usage)" section. 

I chose PNG to be the default image type because the PNG is lossless but good compression. 

*New!*

You can choose a rectangular region surrounding a continuous color region by dragging middle mouse button or <SHIFT> + left mouse button. 
You will see a circle to adjust area roughly and OpenCV cvWatershed function automatically detects a continuous color region. 
You can move the circle by right dragging inside the circle and resize by right dragging around the circle's perimeter.

http://imageclipper.googlecode.com/files/watershed.png

=How to Use (Command Usage) =

{{{

ImageClipper - image clipping helper tool.
Command Usage: imageclipper.exe [option]... [reference]
  <reference = .>
    <reference> would be a directory or an image or a video filename.
    For a directory, image files in the directory will be read sequencially.
    For an image, it is started to read directory from this image file.
    For a video, frames in the video are read sequencially.

  Options
    -f <output_format = imgout_format or vidout_format>
        Determine the output file path format.
        This is a syntax sugar for -i and -v.
        Format Expression)
            %d - dirname of the original
            %i - filename of the original without extension
            %e - filename extension of the original
            %x - upper-left x coord
            %y - upper-left y coord
            %w - width
            %h - height
            %f - frame number (for video)
        Example) ./$i_%04x_%04y_%04w_%04h.%e
            Store into software directory and use image type of the original.
        Supported Image Type)
            bmp|dib|jpeg|jpg|jpe|png|pbm|pgm|ppm|sr|ras|tiff|exr|jp2
    -i <imgout_format = %d/imageclipper/%i.%e_%04x_%04y_%04w_%04h.png>
        Determine the output file path format for image inputs.
    -v <vidout_format = %d/imageclipper/%i.%e_%04f_%04x_%04y_%04w_%04h.png>
        Determine the output file path format for a video input.
    -h
    --help
        Show this help
    -s
    --show
        Show clipped image
}}}

You may make a batch file (Windows) or a shell script or an alias (Linux) to setup default values. Use of -i and -v rather than -f would be useful in that case. 
 
=How to Compile (Linux)=


You need to install [http://sourceforge.net/projects/opencvlibrary/ OpenCV] and [http://www.boost.org Boost] libraries. 

==Install OpenCV==

[http://sourceforge.net/project/showfiles.php?group_id=22870&package_id=16948&release_id=461516 Download OpenCV] source codes (.tar.gz)

root user
{{{
tar zxvf opencv-1.0.0.tar.gz; cd opencv-1.0.0
./configure
make
make install
}}}

general user
{{{
tar zxvf opencv-1.0.0.tar.gz; cd opencv-1.0.0
./configure --prefix=$HOME/usr
make
make install
}}}

{{{
export PATH=$HOME/usr/bin/:$PATH
export LD_LIBRARY_PATH=$HOME/usr/lib:$LD_LIBRARY_PATH
export PKG_CONFIG_PATH=$HOME/usr/lib/pkgconfig:$PKG_CONFIG_PATH
export MANPATH=$HOME/usr/man:$MANPATH
}}}


==Install Boost==

root user and Red Hat (Fedora)
{{{
yum install boost
yum install boost-dev
}}}

root user and Debian (Ubunts)
{{{
apt-get install boost
apt-get install boost-dev
}}}

general user

[http://sourceforge.net/project/showfiles.php?group_id=7586&package_id=8041 Download Boost] source codes (.tar.gz)

{{{
tar zxvf boost_1_36_0.tar.gz; cd boost_1_36_0
./configure --prefix=$HOME/usr
make install
}}}

Reference: [http://www.boost.org/doc/libs/1_36_0/more/getting_started/unix-variants.html Boost Getting Started on Unix Variants]

==Compile==

Unarchive imageclipper.zip. A Makefile is attached. Modify as follows:

  # If you installed boost not on $HOME/usr/: modify ~/usr/ to your path such as /usr/
  # If your boost version is not boost_1_36_0: modify boost-1_36 to your version. Verify with $ ls /path/to/yourboost/include/boost
  # Modify -lboost_system-gcc41-mt -lboost_regex-gcc41-mt -lboost_filesystem-gcc41-mt to yours. Find names by $ ls /path/to/yourboost/lib. If you find names as libboost_regex-gcc41-mt.a, then => -lboost_regex-gcc41-mt

I don't know why boost library uses different names under different system. 
It requires us to modify Makefile as above in different system.... anyway,

Finally
{{{
make
}}}

You should get an executable file "imageclipper". 


=How to Compile (Windows)=

A binary file for Windows is already attached. 
This section explains how to compile for those who want to modify source codes and create a modified software. 

You need to install [http://sourceforge.net/projects/opencvlibrary/ OpenCV] and [http://www.boost.org Boost] libraries. 

==Install OpenCV==

[http://sourceforge.net/project/showfiles.php?group_id=22870&package_id=16937&release_id=456897 Download OpenCV] installer and install it. I assume you have installed onto C:\Program Files\OpenCV. 

==Install Boost==

[http://www.boostpro.com/products/free Download boost] installer and install it. I assume you have installed onto C:\Program Files\boost\boost_1_35_0. 

Reference: [http://www.boost.org/doc/libs/1_36_0/more/getting_started/windows.html Boost Getting Started on Windows]

==Setup MS Visual C++==

I write details based on MS Visual Studio 2005. 
Change boost_1_35_0 if your version is different. 
Follow menus of MS Visual C++ window as:

  * Tools > Options > Projects and Solutions > VC++ directories > 
    * Show Directory for: > Include Files. Now add
{{{
C:\Program Files\boost\boost_1_35_0
C:\Program Files\OpenCV\cv\include
C:\Program Files\OpenCV\cvaux\include
C:\Program Files\OpenCV\cxcore\include
C:\Program Files\OpenCV\otherlibs\highgui
}}}
    * Show Directory for: > Library Files. Now add
{{{
C:\Program Files\boost\boost_1_35_0\lib
C:\Program Files\OpenCV\lib
}}}

==Compile==

Unarchive imageclipper.zip and open imageclipper.sln, then Build. 

=Creating a text file to locate clipped region==

A text file containing locations of clipped region is sometimes required rather than clipped images themselves, e.g., as a ground truth text for testing experiments in computer vision.

Assume there exist files as follows:
{{{
$ \ls imageclipper/*_*_*
image.jpg_0068_0047_0089_0101.png
image.jpg_0087_0066_0090_0080.png
image.jpg_0095_0105_0033_0032.png
image.jpg_0109_0093_0065_0090.png
image.jpg_0117_0097_0052_0095.png
}}}
By executing the following command,
{{{
$ find imageclipper/*_*_* -exec basename \{\} \; | perl -pe 's/_0*(\d+)_0*(\d+)_0*(
\d+)_0*(\d+)\.[^.]*$/ $1 $2 $3 $4\n/g' | tee clipping.txt
}}}
you can obtain a text file "clipping.txt" as follows:
{{{
image.jpg 68 47 89 101
image.jpg 87 66 90 80
image.jpg 95 105 33 32
image.jpg 109 93 65 90
image.jpg 117 97 52 95
}}}

I think this file format is a typical format for testing experiments in many computer vision tools. 

==For OpenCV haartraing Users==

Use haartrainingformat.pl that I attached to imageclipper.zip as
{{{
$ perl haartrainingformat.pl clipping.txt | tee info.dat
}}}
where clipping.txt is the text file created at the previous section to create a OpenCV haartraining suitable format such as
{{{
image.jpg 5 68 47 89 101 87 66 90 80 95 105 33 32 109 93 65 90 117 97 52 95
}}}

Or you can generate a file without creating "clipping.txt" as
{{{
$ \ls imageclipper/*_*_* | perl haartrainingformat.pl --ls --trim --basename | tee info.dat
}}}

Note that a file of this format is required for testing, but clipped images themselves are enough or better for training in fact. See [http://note.sonots.com/SciSoftware/haartraining.html#o40a43fd Tutorial: OpenCV haartraining]

Usage
{{{
Helper tool to convert a specific format into a haartraining format.
Usage: perl haartrainingformat.pl [option]... [filename]
    filename
        file to be read. STDIN is also supported.
Options:
    -l
    --ls
        input is an output of ls.
    -t
    --trim
        trim heading 0 of numbers like from 00xx to xx.
    -b
    --basename
        get basenames from filenames.
    -h
    --help
        show this help.
}}}